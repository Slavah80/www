<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberSec Work Showcase</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <div id="matrix-bg"></div>
    <div class="container">
        <header class="header">
            <h1>Remote Cybersecurity Opportunities</h1>
            <p class="subtitle">A collection of my recent projects and analyses</p>
        </header>

        <div class="search-section">
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Filter by project name..." class="search-input">
                <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
            </div>
        </div>

        <div class="results-section">
            <div id="loadingSpinner" class="loading hidden">
                <div class="spinner"></div>
                <p>Accessing Secure Archives...</p>
            </div>
            
            <div id="errorMessage" class="error hidden"></div>
            
            <div id="resultsContainer" class="results-container hidden">
                <div id="fileList" class="file-list"></div>
                <div id="pagination" class="pagination-container"></div>
            </div>
        </div>
    </div>

    <script>
        class GitHubFileExplorer {
            constructor() {
                this.repoUrl = 'https://github.com/Slavah80/www';
                this.folderPath = 'test';
                this.apiUrl = `https://api.github.com/repos/Slavah80/www/contents/${this.folderPath}`;
                this.files = [];
                this.filteredFiles = [];
                this.currentPage = 1;
                this.entriesPerPage = 10;
                
                this.initializeElements();
                this.bindEvents();
                this.loadFiles();
            }

            initializeElements() {
                this.searchInput = document.getElementById('searchInput');
                this.loadingSpinner = document.getElementById('loadingSpinner');
                this.errorMessage = document.getElementById('errorMessage');
                this.resultsContainer = document.getElementById('resultsContainer');
                this.fileList = document.getElementById('fileList');
                this.paginationContainer = document.getElementById('pagination');
            }

            bindEvents() {
                this.searchInput.addEventListener('input', () => {
                    this.currentPage = 1;
                    this.handleSearch();
                });
            }

            async loadFiles() {
                try {
                    this.showLoading();
                    const response = await fetch(this.apiUrl, {
                        headers: {
                            // To avoid rate-limiting on extensive testing, a personal GitHub token can be used.
                            // 'Authorization': `token YOUR_GITHUB_TOKEN`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`[403] Forbidden. The API rate limit has likely been exceeded.`);
                    }
                    
                    const data = await response.json();
                    const filesWithoutExt = data.filter(item => item.type === 'file' && !item.name.includes('.'));

                    const filePromises = filesWithoutExt.map(async file => {
                        const contentResponse = await fetch(file.download_url);
                        if (!contentResponse.ok) return null;

                        const content = await contentResponse.text();
                        const commitResponse = await fetch(`https://api.github.com/repos/Slavah80/www/commits?path=${file.path}&per_page=1`);
                        let lastModified = 'N/A';
                        if(commitResponse.ok) {
                            const commits = await commitResponse.json();
                            if(commits.length > 0) {
                                lastModified = new Date(commits[0].commit.committer.date).toLocaleDateString('en-CA');
                            }
                        }

                        return {
                            name: file.name,
                            content: content,
                            lastModified: lastModified,
                        };
                    });
                    
                    this.files = (await Promise.all(filePromises)).filter(Boolean); // Filters out any null entries
                    this.filteredFiles = [...this.files];

                    this.displayPage();
                    this.hideLoading();
                    
                } catch (error) {
                    this.showError(`Error fetching data: ${error.message}`);
                    this.hideLoading();
                }
            }

            handleSearch() {
                const query = this.searchInput.value.toLowerCase().trim();
                this.filteredFiles = this.files.filter(file =>
                    file.name.toLowerCase().includes(query)
                );
                this.displayPage();
            }
        
            displayPage() {
                if (this.filteredFiles.length === 0) {
                    this.fileList.innerHTML = '';
                    this.paginationContainer.innerHTML = '';
                    this.showError('No matching projects were found.');
                    return;
                }

                this.hideError();
                this.resultsContainer.classList.remove('hidden');

                const startIndex = (this.currentPage - 1) * this.entriesPerPage;
                const endIndex = startIndex + this.entriesPerPage;
                const paginatedFiles = this.filteredFiles.slice(startIndex, endIndex);

                this.fileList.innerHTML = paginatedFiles.map(file => {
                    const wordCount = file.content.split(/\s+/).filter(Boolean).length;
                    const readTime = Math.ceil(wordCount / 200); // Assumes an average reading speed of 200 words per minute
                    
                    return `
                        <div class="file-item">
                            <div class="file-header" onclick="this.parentElement.classList.toggle('expanded')">
                                <span class="file-name">${file.name}</span>
                                <div class="file-meta">
                                    <span class="file-read-time">~${readTime} min read</span>
                                    <span class="file-date">Last updated: ${file.lastModified}</span>
                                    <span class="expand-icon">+</span>
                                </div>
                            </div>
                            <div class="file-content">
                                <pre><code>${this.escapeHtml(file.content)}</code></pre>
                            </div>
                        </div>
                    `;
                }).join('');
                
                this.setupPagination();
            }

            setupPagination() {
                const pageCount = Math.ceil(this.filteredFiles.length / this.entriesPerPage);
                this.paginationContainer.innerHTML = '';
                
                if (pageCount <= 1) return;

                for (let i = 1; i <= pageCount; i++) {
                    const btn = document.createElement('button');
                    btn.className = `pagination-btn ${i === this.currentPage ? 'active' : ''}`;
                    btn.innerText = i;
                    btn.addEventListener('click', () => {
                        this.currentPage = i;
                        this.displayPage();
                        window.scrollTo(0, 0); // Scrolls to the top of the page on new page load
                    });
                    this.paginationContainer.appendChild(btn);
                }
            }
            
            escapeHtml(text) {
                return text.replace(/</g, "<").replace(/>/g, ">");
            }

            showLoading() { this.loadingSpinner.classList.remove('hidden'); }
            hideLoading() { this.loadingSpinner.classList.add('hidden'); }
            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.classList.remove('hidden');
                
                if (this.files.length === 0) {
                   this.resultsContainer.classList.add('hidden');
                }
            }
            hideError() { this.errorMessage.classList.add('hidden'); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GitHubFileExplorer();
            
            const canvas = document.createElement('canvas');
            const matrixBg = document.getElementById('matrix-bg');
            matrixBg.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const letters = 'availabilityZone array autoGeneratedDomainNameLabelScope avmTelemetry cMKKeyVault cMKKey cMKUserAssignedIdentity container containerGpuType containerGroupSubnetIdType containerProbeType containerType containergroup containergroup_lock containers cpu customerManagedKey dnsConfig dnsConfigType empty enableTelemetry environmentVariables formattedUserAssignedIdentities gpu identity iPv4Address image imageRegistryCredentials imageRegistryCredentialType initContainers ipAddress ipAddressPortsType ipAddressType json last location lock logAnalytics logAnalyticsType map memoryInGB metadata name priority reduce replace resourceGroupName resourceId restartPolicy sku split subnets systemAssignedMIPrincipalId tags uniqueString union volumes';
            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);

            function drawMatrix() {
                ctx.fillStyle = 'rgba(10, 25, 47, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00f7a5'; 
                ctx.font = `${fontSize}px Roboto Mono`;
                
                for (let i = 0; i < drops.length; i++) {
                    const text = letters[Math.floor(Math.random() * letters.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            setInterval(drawMatrix, 40);

            window.addEventListener('resize', () => {
                 canvas.width = window.innerWidth;
                 canvas.height = window.innerHeight;
            });
        });
    </script>
</body>
</html>
